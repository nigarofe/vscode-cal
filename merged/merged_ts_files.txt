# Project Folder Structure

├───.gemini
│   ├───.env
│   ├───api_keys.json
│   ├───GEMINI.md
│   ├───rotate_keys.js
│   └───run_rotate_keys.bat
├───.gitignore
├───.vscode-test.mjs
├───.vscodeignore
├───CAL3
│   ├───package.json
│   └───src
│       ├───client.ts
│       ├───components
│       │   ├───add-question-form.html
│       │   ├───autohide-navbar.css
│       │   ├───Book.svg
│       │   ├───edit-question-form.html
│       │   ├───main-header.html
│       │   ├───Obsidian_logo.svg
│       │   ├───questions-table-mini.html
│       │   ├───questions-table.html
│       │   ├───sticky-navbar.html
│       │   └───toast.html
│       ├───index.html
│       ├───load_components.ts
│       ├───rec_sys.ts
│       ├───server_get.ts
│       └───server_post.ts
├───CHANGELOG.md
├───eslint.config.mjs
├───features
│   ├───export
│   │   ├───design.md
│   │   ├───requirements.md
│   │   └───tasks.md
│   ├───prompt.md
│   ├───question-management
│   │   ├───design.md
│   │   ├───requirements.md
│   │   └───tasks.md
│   ├───README.md
│   ├───recommendation
│   │   ├───design.md
│   │   ├───requirements.md
│   │   └───tasks.md
│   ├───render-question
│   │   ├───design.md
│   │   ├───requirements.md
│   │   └───tasks.md
│   └───validation-and-diagnostics
│       ├───design.md
│       ├───requirements.md
│       └───tasks.md
├───images
│   ├───diagram.png
│   └───icon.svg
├───jest.config.js
├───media
│   ├───main.css
│   ├───reset.css
│   └───vscode.css
├───package-lock.json
├───package.json
├───README.md
├───src
│   ├───.json
│   │   ├───2025-07-17T16-01-21_461Z_questions.json
│   │   ├───2025-07-21T17-46-29_121Z_questions.json
│   │   └───question_schema.json
│   ├───commands
│   │   ├───commandsLoader.ts
│   │   ├───createQuestion.ts
│   │   ├───exportQuestionsJson.ts
│   │   ├───onDidChangeTextDocument.ts
│   │   ├───openQuestionByNumber.ts
│   │   ├───previewQuestion.ts
│   │   ├───recommendQuestion.ts
│   │   ├───registerAttempt.ts
│   │   ├───saveQuestion.ts
│   │   └───showRankedQuestions.ts
│   ├───db.db
│   ├───db.ts
│   ├───db_sql_queries.ts
│   ├───diagnostics.ts
│   ├───extension.ts
│   ├───Question.ts
│   ├───sidepanel.html
│   ├───sidepanelProvider.ts
│   ├───test
│   │   ├───extension.test.ts
│   │   └───question-management.test.ts
│   └───webview.ts
├───src.code-workspace
├───tsconfig.json
├───types
│   └───markdown-it-katex.d.ts
└───_misc
    ├───01_user_workflows.md
    ├───analytical_rubrics
    │   ├───answers.json
    │   └───questions.json
    ├───flows_and_architectures
    │   ├───01_system_overview.md
    │   ├───02_learning_materials_architecture.md
    │   ├───03_user_workflows.md
    │   └───04_tagging_workflow.md
    ├───learning_materials
    │   ├───.obsidian
    │   │   ├───app.json
    │   │   ├───appearance.json
    │   │   ├───community-plugins.json
    │   │   ├───core-plugins.json
    │   │   ├───hotkeys.json
    │   │   ├───plugins
    │   │   │   ├───creases
    │   │   │   │   ├───main.js
    │   │   │   │   ├───manifest.json
    │   │   │   │   └───styles.css
    │   │   │   ├───obsidian-latex-suite
    │   │   │   │   ├───main.js
    │   │   │   │   ├───manifest.json
    │   │   │   │   └───styles.css
    │   │   │   └───templater-obsidian
    │   │   │       ├───data.json
    │   │   │       ├───main.js
    │   │   │       ├───manifest.json
    │   │   │       └───styles.css
    │   │   ├───templates.json
    │   │   └───workspace.json
    │   ├───premise-sets-md
    │   │   ├───ps1.md
    │   │   ├───ps10.md
    │   │   ├───ps11.md
    │   │   ├───ps12.md
    │   │   ├───ps13.md
    │   │   ├───ps14.md
    │   │   ├───ps15.md
    │   │   ├───ps16.md
    │   │   ├───ps17.md
    │   │   ├───ps18.md
    │   │   ├───ps19.md
    │   │   ├───ps2.md
    │   │   ├───ps20.md
    │   │   ├───ps21.md
    │   │   ├───ps22.md
    │   │   ├───ps23.md
    │   │   ├───ps24.md
    │   │   ├───ps25.md
    │   │   ├───ps26.md
    │   │   ├───ps27.md
    │   │   ├───ps28.md
    │   │   ├───ps29.md
    │   │   ├───ps3.md
    │   │   ├───ps30.md
    │   │   ├───ps31.md
    │   │   ├───ps32.md
    │   │   ├───ps33.md
    │   │   ├───ps34.md
    │   │   ├───ps35.md
    │   │   ├───ps4.md
    │   │   ├───ps5.md
    │   │   ├───ps6.md
    │   │   ├───ps7.md
    │   │   ├───ps8.md
    │   │   ├───ps9.md
    │   │   └───Summary.md
    │   ├───premises-images
    │   │   ├───ps11.png
    │   │   ├───ps19.svg
    │   │   ├───ps24-1.svg
    │   │   ├───ps24-2.svg
    │   │   ├───ps25-1.svg
    │   │   ├───ps25-2.svg
    │   │   ├───ps26-1.svg
    │   │   ├───ps26-2.svg
    │   │   ├───ps26-3.svg
    │   │   ├───ps30-1.svg
    │   │   ├───ps30-2.svg
    │   │   ├───ps30-3.png
    │   │   ├───ps30-4.png
    │   │   └───ps4.png
    │   ├───question-images
    │   │   ├───pending
    │   │   │   ├───latex-conversion
    │   │   │   │   ├───Photos-1-001.zip
    │   │   │   │   ├───q17.jpg
    │   │   │   │   ├───q19-2.jpg
    │   │   │   │   ├───q19.jpg
    │   │   │   │   ├───q19.png
    │   │   │   │   ├───q26.jpg
    │   │   │   │   ├───q28.jpg
    │   │   │   │   ├───q40.png
    │   │   │   │   ├───q43.jpg
    │   │   │   │   ├───q51.png
    │   │   │   │   ├───q68.jpg
    │   │   │   │   ├───q72 q73 q74 (2).jpg
    │   │   │   │   ├───q72 q73 q74.jpg
    │   │   │   │   ├───q75 q76 (2).jpg
    │   │   │   │   ├───q75 q76.jpg
    │   │   │   │   ├───q76.jpg
    │   │   │   │   ├───q77 q78 (2).jpg
    │   │   │   │   ├───q77 q78.jpg
    │   │   │   │   ├───q77.jpg
    │   │   │   │   ├───q87.jpg
    │   │   │   │   ├───q88 matriz.png
    │   │   │   │   ├───q88-2.jpg
    │   │   │   │   ├───q88.jpg
    │   │   │   │   ├───q9.jpg
    │   │   │   │   ├───q90.jpg
    │   │   │   │   ├───q91.jpg
    │   │   │   │   ├───q95-2.jpg
    │   │   │   │   ├───q95.jpg
    │   │   │   │   └───q96.jpg
    │   │   │   └───to-become-questions
    │   │   │       ├───IMG_20250519_173343072_MP.jpg
    │   │   │       ├───Screenshot_20250519-174306.png
    │   │   │       └───Screenshot_20250519-174732.png
    │   │   ├───q1.png
    │   │   ├───q10.png
    │   │   ├───q11.png
    │   │   ├───q110.png
    │   │   ├───q12.png
    │   │   ├───q121.png
    │   │   ├───q123.png
    │   │   ├───q124.png
    │   │   ├───q125.png
    │   │   ├───q126.png
    │   │   ├───q129.png
    │   │   ├───q13.jpeg
    │   │   ├───q130.png
    │   │   ├───q16.png
    │   │   ├───q17.png
    │   │   ├───q18.png
    │   │   ├───q2.jpg
    │   │   ├───q24.jpg
    │   │   ├───q25.jpg
    │   │   ├───q26.jpg
    │   │   ├───q27.jpg
    │   │   ├───q28.png
    │   │   ├───q29.png
    │   │   ├───q3.png
    │   │   ├───q30.png
    │   │   ├───q31.png
    │   │   ├───q34.png
    │   │   ├───q35.png
    │   │   ├───q39.png
    │   │   ├───q4.png
    │   │   ├───q40.png
    │   │   ├───q41.png
    │   │   ├───q42.png
    │   │   ├───q43.png
    │   │   ├───q44.png
    │   │   ├───q45.png
    │   │   ├───q46.png
    │   │   ├───q47.png
    │   │   ├───q48.png
    │   │   ├───q49.png
    │   │   ├───q5.jpg
    │   │   ├───q50.png
    │   │   ├───q51.png
    │   │   ├───q52.jpg
    │   │   ├───q53.jpg
    │   │   ├───q54.jpg
    │   │   ├───q55.jpg
    │   │   ├───q56.jpg
    │   │   ├───q57.jpg
    │   │   ├───q58.jpg
    │   │   ├───q59.jpg
    │   │   ├───q60.png
    │   │   ├───q61.png
    │   │   ├───q62.png
    │   │   ├───q63.png
    │   │   ├───q64.png
    │   │   ├───q65.png
    │   │   ├───q68.jpg
    │   │   ├───q7.jpg
    │   │   ├───q8.png
    │   │   ├───q88.png
    │   │   ├───q9.jpg
    │   │   ├───q91.png
    │   │   ├───q96-2.png
    │   │   └───q96.png
    │   ├───questions-md
    │   │   ├───q1.md
    │   │   ├───q10.md
    │   │   ├───q100.md
    │   │   ├───q101.md
    │   │   ├───q102.md
    │   │   ├───q103.md
    │   │   ├───q104.md
    │   │   ├───q105.md
    │   │   ├───q106.md
    │   │   ├───q107.md
    │   │   ├───q108.md
    │   │   ├───q109.md
    │   │   ├───q11.md
    │   │   ├───q110.md
    │   │   ├───q111.md
    │   │   ├───q112.md
    │   │   ├───q115.md
    │   │   ├───q116.md
    │   │   ├───q117.md
    │   │   ├───q118.md
    │   │   ├───q119.md
    │   │   ├───q12.md
    │   │   ├───q120.md
    │   │   ├───q121.md
    │   │   ├───q122.md
    │   │   ├───q123.md
    │   │   ├───q124.md
    │   │   ├───q125.md
    │   │   ├───q126.md
    │   │   ├───q127.md
    │   │   ├───q128.md
    │   │   ├───q129.md
    │   │   ├───q13.md
    │   │   ├───q130.md
    │   │   ├───q14.md
    │   │   ├───q15.md
    │   │   ├───q16.md
    │   │   ├───q17.md
    │   │   ├───q18.md
    │   │   ├───q19.md
    │   │   ├───q2.md
    │   │   ├───q20.md
    │   │   ├───q21.md
    │   │   ├───q22.md
    │   │   ├───q23.md
    │   │   ├───q24.md
    │   │   ├───q25.md
    │   │   ├───q26.md
    │   │   ├───q27.md
    │   │   ├───q28.md
    │   │   ├───q29.md
    │   │   ├───q3.md
    │   │   ├───q30.md
    │   │   ├───q31.md
    │   │   ├───q32.md
    │   │   ├───q33.md
    │   │   ├───q34.md
    │   │   ├───q35.md
    │   │   ├───q36.md
    │   │   ├───q37.md
    │   │   ├───q38.md
    │   │   ├───q39.md
    │   │   ├───q4.md
    │   │   ├───q40.md
    │   │   ├───q41.md
    │   │   ├───q42.md
    │   │   ├───q43.md
    │   │   ├───q44.md
    │   │   ├───q45.md
    │   │   ├───q46.md
    │   │   ├───q47.md
    │   │   ├───q48.md
    │   │   ├───q49.md
    │   │   ├───q5.md
    │   │   ├───q50.md
    │   │   ├───q51.md
    │   │   ├───q52.md
    │   │   ├───q53.md
    │   │   ├───q54.md
    │   │   ├───q55.md
    │   │   ├───q56.md
    │   │   ├───q57.md
    │   │   ├───q58.md
    │   │   ├───q59.md
    │   │   ├───q6.md
    │   │   ├───q60.md
    │   │   ├───q61.md
    │   │   ├───q62.md
    │   │   ├───q63.md
    │   │   ├───q64.md
    │   │   ├───q65.md
    │   │   ├───q66.md
    │   │   ├───q67.md
    │   │   ├───q69.md
    │   │   ├───q7.md
    │   │   ├───q72.md
    │   │   ├───q73.md
    │   │   ├───q74.md
    │   │   ├───q75.md
    │   │   ├───q76.md
    │   │   ├───q77.md
    │   │   ├───q78.md
    │   │   ├───q79.md
    │   │   ├───q8.md
    │   │   ├───q80.md
    │   │   ├───q81.md
    │   │   ├───q82.md
    │   │   ├───q83.md
    │   │   ├───q84.md
    │   │   ├───q85.md
    │   │   ├───q88.md
    │   │   ├───q9.md
    │   │   ├───q90.md
    │   │   ├───q91.md
    │   │   ├───q92.md
    │   │   ├───q93.md
    │   │   ├───q94.md
    │   │   ├───q95.md
    │   │   ├───q96.md
    │   │   ├───q97.md
    │   │   ├───q98.md
    │   │   └───q99.md
    │   └───templates
    │       └───question_template.md
    ├───learning_material_tagging
    │   ├───llm_output.json
    │   ├───llm_prompt.md
    │   ├───merged_materials.json
    │   └───merge_md_files.js
    ├───learning_theory
    │   ├───mnemonic_systems
    │   │   ├───dominic 2.txt
    │   │   ├───Dominic.png
    │   │   └───number-initial-name-action.ods
    │   └───Repetição espaçada e rastreabilidade.md
    ├───migration to db
    │   ├───gemini_system_prompt.md
    │   └───migration_sql.md
    ├───project_ideas
    │   ├───Ideas.md
    │   ├───Scroll Screenshot.png
    │   └───SoftMetrics.md
    ├───prompt_frameworks
    │   ├───Instructional_Design_Engine_v3.0.json
    │   ├───Interacoes_conteudo.json
    │   ├───Interface_Implementations.json
    │   └───Text_Generation.json
    ├───README.md
    └───_changelog.md


// =================================================================================================
// FILE: src/commands/commandsLoader.ts
// =================================================================================================

import * as vscode from "vscode";
import { createQuestionCommand } from "./createQuestion";
import { exportQuestionsJsonCommand } from "./exportQuestionsJson";
import { openQuestionByNumberCommand } from "./openQuestionByNumber";
import { previewQuestionCommand } from "./previewQuestion";
import { saveQuestionCommand } from "./saveQuestion";
import { registerAttemptCommand } from "./registerAttempt";
import { onDidChangeTextDocument } from "./onDidChangeTextDocument";
import { recommendQuestionCommand } from "./recommendQuestion";
import { showRankedQuestionsCommand } from "./showRankedQuestions";

export function registerCommands(context: vscode.ExtensionContext) {
    context.subscriptions.push(createQuestionCommand(context));
    context.subscriptions.push(exportQuestionsJsonCommand(context));
    context.subscriptions.push(openQuestionByNumberCommand(context));
    context.subscriptions.push(previewQuestionCommand(context));
    context.subscriptions.push(saveQuestionCommand());
    context.subscriptions.push(registerAttemptCommand());
    context.subscriptions.push(recommendQuestionCommand(context));
    context.subscriptions.push(showRankedQuestionsCommand(context));
    onDidChangeTextDocument(context);
}


// =================================================================================================
// FILE: src/commands/createQuestion.ts
// =================================================================================================

import * as vscode from "vscode";
import * as sqlite3 from "sqlite3";
import * as path from "path";
import { CREATE_QUESTION_SQL, GET_MAX_QUESTION_NUMBER_SQL } from "../db_sql_queries";

export function createQuestionCommand(context: vscode.ExtensionContext) {
    const command = vscode.commands.registerCommand('vscode-cal.createQuestion', async () => {
        const dbPath = path.join(context.extensionPath, "src", "db.db");
        const db = new sqlite3.Database(dbPath, (err) => {
            if (err) {
                vscode.window.showErrorMessage(`Error opening database: ${err.message}`);
                return;
            }
        });

        db.get(GET_MAX_QUESTION_NUMBER_SQL, [], (err, row: { max_number: number }) => {
            if (err) {
                vscode.window.showErrorMessage(`Error getting max question number: ${err.message}`);
                db.close();
                return;
            }

            const newQuestionNumber = (row.max_number || 0) + 1;

            db.run(CREATE_QUESTION_SQL, ['', '', ``, '', '', '', ''], function (err) {
                if (err) {
                    vscode.window.showErrorMessage(`Error creating new question: ${err.message}`);
                } else {
                    const fileContent = `---
discipline: ""
description: ""
source: ""
tags: []
---

# Question ${newQuestionNumber}

## Proposition

## Step-by-step

## Answer
`;
                    vscode.workspace.openTextDocument({ content: fileContent, language: 'markdown' }).then(doc => {
                        vscode.window.showTextDocument(doc);
                        vscode.window.showInformationMessage(`Created new question #${newQuestionNumber}. Fill in the details and save.`);
                    });
                }
                db.close();
            });
        });
    });

    return command;
}


// =================================================================================================
// FILE: src/commands/exportQuestionsJson.ts
// =================================================================================================

import * as vscode from "vscode";
import * as path from "path";
import { buildAllQuestions } from "../db";

export function exportQuestionsJsonCommand(context: vscode.ExtensionContext) {
    return vscode.commands.registerCommand(
        "vscode-cal.exportQuestionsJson",
        async () => {
            const dbPath = path.join(context.extensionPath, "src", "db.db");
            try {
                const questions = await buildAllQuestions(dbPath);
                const questionsForJson = questions.map((q) => ({
                    number: q.question_number,
                    discipline: q.discipline,
                    source: q.source,
                    description: q.description,
                    proposition: q.proposition,
                    "step-by-step": q.step_by_step,
                    answer: q.answer,
                    tags: q.tags,
                    spaced_repetition_variables: {
                        attempts: q.attempts.map((attempt) => ({
                            datetime: attempt.date.toISOString(),
                            code: attempt.code,
                        })),
                        DSLA: q.daysSinceLastAttempt,
                        LaMI: q.latestMemoryInterval,
                        "PMG-D": q.potentialMemoryGainInDays,
                        "PMG-X": q.potentialMemoryGainMultiplier,
                        total_attempts: q.attemptsWithHelp + q.attemptsWithoutHelp,
                        memory_attempts: q.attemptsWithoutHelp,
                        help_attempts: q.attemptsWithHelp,
                        attempts_summary: q.attemptsSummary,
                    },
                }));

                const questionsAsJson = JSON.stringify(
                    { questions: questionsForJson },
                    null,
                    2
                );
                const jsonFolderPath = path.join(context.extensionPath, "src", ".json");

                try {
                    await vscode.workspace.fs.stat(vscode.Uri.file(jsonFolderPath));
                } catch (error) {
                    await vscode.workspace.fs.createDirectory(
                        vscode.Uri.file(jsonFolderPath)
                    );
                }

                const timestamp = new Date()
                    .toISOString()
                    .replace(/:/g, "-")
                    .replace(/\./, "_");
                const filePath = path.join(
                    jsonFolderPath,
                    `${timestamp}_questions.json`
                );
                await vscode.workspace.fs.writeFile(
                    vscode.Uri.file(filePath),
                    Buffer.from(questionsAsJson, "utf8")
                );
                vscode.window.showInformationMessage(
                    `Successfully exported questions to ${filePath}`
                );
            } catch (error: any) {
                vscode.window.showErrorMessage(error);
            }
        }
    );
}


// =================================================================================================
// FILE: src/commands/onDidChangeTextDocument.ts
// =================================================================================================

import * as vscode from "vscode";
import { getWebviewContent } from "../webview";
import { getPanels } from "./previewQuestion";

let debounce: NodeJS.Timeout | undefined = undefined;

export function onDidChangeTextDocument(context: vscode.ExtensionContext) {
    vscode.workspace.onDidChangeTextDocument((event) => {
        const panels = getPanels();
        if (
            panels.length > 0 &&
            event.document === vscode.window.activeTextEditor?.document
        ) {
            if (debounce) {
                clearTimeout(debounce);
            }
            debounce = setTimeout(() => {
                panels.forEach((panel) => {
                    if (panel.visible) {
                        panel.webview.html = getWebviewContent(
                            event.document.getText(),
                            panel!,
                            context
                        );
                    }
                });
            }, 300);
        }
    });
}


// =================================================================================================
// FILE: src/commands/openQuestionByNumber.ts
// =================================================================================================

import * as vscode from "vscode";
import * as path from "path";
import { buildAllQuestions } from "../db";
import { updateDiagnostics } from "../diagnostics";

export function openQuestionByNumberCommand(context: vscode.ExtensionContext) {
    return vscode.commands.registerCommand(
        "vscode-cal.openQuestionByNumber",
        async (questionNumber?: number) => {
            let questionNumberStr: string | undefined;

            if (questionNumber === undefined) {
                questionNumberStr = await vscode.window.showInputBox({
                    prompt: "Enter the question number",
                    placeHolder: "e.g., 1",
                    validateInput: (text) => {
                        return /^\d+$/.test(text) ? null : "Please enter a valid number.";
                    },
                });
            } else {
                questionNumberStr = questionNumber.toString();
            }

            if (questionNumberStr) {
                const questionNumber = parseInt(questionNumberStr, 10);
                const dbPath = path.join(context.extensionPath, "src", "db.db");
                try {
                    const questions = await buildAllQuestions(dbPath);
                    const question = questions.find(
                        (q) => q.question_number === questionNumber
                    );

                    if (question) {
                        const frontMatter = {
                            discipline: question.discipline,
                            description: question.description,
                            source: question.source,
                            tags: question.tags,
                        };

                        const content =
                            `---\n` +
                            `${Object.entries(frontMatter)
                                .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
                                .join("\n")}\n` +
                            `---\n\n` +
                            `# Question ${question.question_number}\n\n` +
                            `## Proposition\n${question.proposition}\n\n` +
                            `## Step-by-step\n${question.step_by_step || ""}\n\n` +
                            `## Answer\n${question.answer}\n\n`;

                        const doc = await vscode.workspace.openTextDocument({
                            content: content,
                            language: "markdown",
                        });
                        await vscode.window.showTextDocument(doc);
                        updateDiagnostics(doc);
                    } else {
                        vscode.window.showErrorMessage(
                            `Question number ${questionNumber} not found.`
                        );
                    }
                } catch (error: any) {
                    vscode.window.showErrorMessage(error.message);
                }
            }
        }
    );
}

// =================================================================================================
// FILE: src/commands/previewQuestion.ts
// =================================================================================================

import * as vscode from "vscode";
import { getWebviewContent } from "../webview";

let panels: vscode.WebviewPanel[] = [];

export function previewQuestionCommand(context: vscode.ExtensionContext) {
    return vscode.commands.registerCommand(
        "vscode-cal.previewQuestion",
        () => {
            const editor = vscode.window.activeTextEditor;
            if (!editor) {
                vscode.window.showInformationMessage("No active editor");
                return;
            }

            const text = editor.document.getText();
            const questionNumberMatch = text.match(/^# Question (\d+)/im);
            const questionNumber = questionNumberMatch ? questionNumberMatch[1] : " ";

            const roots = [
                context.extensionUri,
                ...(vscode.workspace.workspaceFolders || []).map(
                    (folder) => folder.uri
                ),
            ].filter(Boolean) as vscode.Uri[];

            const panel = vscode.window.createWebviewPanel(
                "questionPreview",
                `Preview Q${questionNumber}`,
                vscode.ViewColumn.Two,
                {
                    enableScripts: true,
                    localResourceRoots: roots, // Use the 'roots' variable here
                }
            );

            panels.push(panel);

            panel.onDidDispose(
                () => {
                    panels = panels.filter((p) => p !== panel);
                },
                null,
                context.subscriptions
            );

            panel.webview.html = getWebviewContent(
                editor.document.getText(),
                panel,
                context
            );
        }
    );
}

export function getPanels() {
    return panels;
}


// =================================================================================================
// FILE: src/commands/recommendQuestion.ts
// =================================================================================================

import * as vscode from "vscode";
import * as path from "path";
import { buildAllQuestions } from "../db";
import { Question } from "../Question";

export function recommendQuestionCommand(context: vscode.ExtensionContext) {
  return vscode.commands.registerCommand(
    "vscode-cal.recommendQuestion",
    async () => {
      const dbPath = path.join(context.extensionPath, "src", "db.db");
      try {
        const questions = await buildAllQuestions(dbPath);
        let recommendedQuestion: Question | null = null;
        let maxMultiplier = -1;

        for (const question of questions) {
          if (
            typeof question.potentialMemoryGainMultiplier === "number" &&
            question.potentialMemoryGainMultiplier > maxMultiplier
          ) {
            maxMultiplier = question.potentialMemoryGainMultiplier;
            recommendedQuestion = question;
          }
        }

        if (recommendedQuestion) {
          vscode.commands.executeCommand(
            "vscode-cal.openQuestionByNumber",
            recommendedQuestion.question_number
          );
        } else {
          vscode.window.showInformationMessage(
            "No questions available for recommendation."
          );
        }
      } catch (error: any) {
        vscode.window.showErrorMessage(error.message);
      }
    }
  );
}


// =================================================================================================
// FILE: src/commands/registerAttempt.ts
// =================================================================================================

import * as vscode from "vscode";
import { registerAttempt } from "../db";

export function registerAttemptCommand() {
    return vscode.commands.registerCommand(
        "vscode-cal.registerAttempt",
        async (attemptCode?: number) => {
            const editor = vscode.window.activeTextEditor;
            if (!editor) {
                vscode.window.showInformationMessage("No active editor.");
                return;
            }
            const text = editor.document.getText();
            const questionNumberMatch = text.match(/^# Question (\d+)/im);
            if (!questionNumberMatch) {
                vscode.window.showErrorMessage("Could not determine question number.");
                return;
            }
            const questionNumber = parseInt(questionNumberMatch[1], 10);

            if (attemptCode === undefined) {
                const attemptCodeStr = await vscode.window.showInputBox({
                    prompt: "Enter the attempt code (0 for with help, 1 for without help)",
                    placeHolder: "e.g., 1",
                    validateInput: (text) => {
                        return /^[01]$/.test(text) ? null : "Please enter 0 or 1.";
                    },
                });
                if (attemptCodeStr) {
                    attemptCode = parseInt(attemptCodeStr, 10);
                } else {
                    return; // User cancelled the input
                }
            }

            registerAttempt(questionNumber, attemptCode);
        }
    );
}

// =================================================================================================
// FILE: src/commands/saveQuestion.ts
// =================================================================================================

import * as vscode from "vscode";
import { saveQuestion } from "../db";
import { diagnosticsCollection, updateDiagnostics } from "../diagnostics";

export function saveQuestionCommand() {
    return vscode.commands.registerCommand(
        "vscode-cal.saveQuestion",
        () => {
            const editor = vscode.window.activeTextEditor;
            if (!editor) {
                vscode.window.showInformationMessage("No active editor to save.");
                return;
            }
            const doc = editor.document;
            updateDiagnostics(doc);
            if (diagnosticsCollection.get(doc.uri)?.length) {
                vscode.window.showErrorMessage(
                    "Cannot save, please fix the errors first."
                );
                return;
            }
            saveQuestion(doc);
        }
    );
}


// =================================================================================================
// FILE: src/commands/showRankedQuestions.ts
// =================================================================================================

import * as vscode from "vscode";
import { buildAllQuestions } from "../db";
import { Question } from "../Question";
import * as path from "path";

export function showRankedQuestionsCommand(context: vscode.ExtensionContext) {
    return vscode.commands.registerCommand('vscode-cal.showRankedQuestions', () => {
        const dbPath = path.resolve(__dirname, "../../src/db.db");

        buildAllQuestions(dbPath).then(questions => {
            // Filter out questions where potentialMemoryGainMultiplier is not a number
            // const sortedQuestions = questions.filter(q => typeof q.potentialMemoryGainMultiplier === 'number');
            const sortedQuestions = questions;

            // Sort questions by potential memory gain multiplier in descending order
            sortedQuestions.sort((a, b) => {
                const pmgA = a.potentialMemoryGainMultiplier;
                const pmgB = b.potentialMemoryGainMultiplier;

                const isNumA = typeof pmgA === 'number';
                const isNumB = typeof pmgB === 'number';

                if (isNumA && isNumB) {
                    return pmgB - pmgA;
                }
                if (isNumA) {
                    return -1; // A (number) comes before B (string)
                }
                if (isNumB) {
                    return 1; // B (number) comes after A (string)
                }

                // Both are strings, sort based on a predefined order
                const stringOrder = ['W/H', 'SA', 'NA'];
                const indexA = stringOrder.indexOf(pmgA as string);
                const indexB = stringOrder.indexOf(pmgB as string);

                return indexA - indexB;
            });

            const panel = vscode.window.createWebviewPanel(
                'rankedQuestions',
                'Ranked Questions by Memory Gain',
                vscode.ViewColumn.One,
                {
                    enableScripts: true
                }
            );

            panel.webview.html = getWebviewContent(sortedQuestions);

            panel.webview.onDidReceiveMessage(
                message => {
                    switch (message.command) {
                        case 'openQuestionByNumber':
                            vscode.commands.executeCommand('vscode-cal.openQuestionByNumber', message.questionNumber);
                            return;
                    }
                },
                undefined,
                context.subscriptions
            );
        }).catch(err => {
            vscode.window.showErrorMessage("Failed to build questions: " + err);
        });
    });
}

function getWebviewContent(questions: Question[]): string {
    const tableHeaders = [
        "#",
        "Discipline",
        "Source",
        "Description",
        "Attempts Summary",
        "DSLA",
        "LaMI",
        "PMG-D",
        "PMG-X",
    ];

    const headerHtml = tableHeaders.map(header => `<th>${header}</th>`).join('');

    const numericPmgs = questions
        .map(q => q.potentialMemoryGainMultiplier)
        .filter(pmg => typeof pmg === 'number' && pmg > 1) as number[];

    const minPmg = Math.min(...numericPmgs);
    const maxPmg = Math.max(...numericPmgs);

    const rows = questions.map(q => {
        const pmgX = q.potentialMemoryGainMultiplier;
        const colorStyle = getHighlightColor(pmgX, minPmg, maxPmg);

        return `
        <tr data-question-number="${q.question_number}" style="cursor: pointer; ${colorStyle}">
            <td>${q.question_number}</td>
            <td>${q.discipline}</td>
            <td>${q.source}</td>
            <td>${q.description}</td>
            <td>${q.attemptsSummary}</td>
            <td>${q.daysSinceLastAttempt}</td>
            <td>${q.latestMemoryInterval}</td>
            <td>${q.potentialMemoryGainInDays}</td>
            <td>${pmgX}</td>
        </tr>
    `;
    }).join('');

    return `
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Ranked Questions</title>
            <style>
                table {
                    width: 100%;
                    border-collapse: collapse;
                }
                th, td {
                    border: 1px solid #ddd;
                    padding: 8px;
                    text-align: left;
                }
                th {
                    background-color: #f2f2f2;
                    cursor: pointer;
                    user-select: none;
                }
                th.sort-asc::after {
                    content: ' ▲';
                }
                th.sort-desc::after {
                    content: ' ▼';
                }
                tr:hover {
                    background-color: #f5f5f5 !important;
                    color: black !important;
                }
            </style>
        </head>
        <body>
            <h1>Questions Ranked by PMG-X ${rows.length}</h1>
            <table id="questionsTable">
                <thead>
                    <tr>
                        ${headerHtml}
                    </tr>
                </thead>
                <tbody>
                    ${rows}
                </tbody>
            </table>
            <script>
                const vscode = acquireVsCodeApi();
                document.querySelectorAll('tr[data-question-number]').forEach(row => {
                    row.addEventListener('click', event => {
                        const questionNumber = row.dataset.questionNumber;
                        if (questionNumber) {
                            vscode.postMessage({
                                command: 'openQuestionByNumber',
                                questionNumber: parseInt(questionNumber)
                            });
                        }
                    });
                });

                document.querySelectorAll('#questionsTable th').forEach((header, index) => {
                    header.addEventListener('click', () => {
                        sortTable(index);
                    });
                });

                let sortDirections = [];

                function getPmgxHighlightColor(pmgX, minPmg, maxPmg) {
                    if (typeof pmgX === 'string') {
                        switch (pmgX) {
                            case 'NA': return 'background-color: #F0F0F0;';
                            case 'SA': return 'background-color: #E6E0F8;';
                            case 'W/H': return 'background-color: #FFDDC1;';
                            default: return '';
                        }
                    }
                    if (pmgX <= 1) {
                        return 'background-color: #006400; color: white;';
                    }
                    const hue = 120 * (1 - (pmgX - minPmg) / (maxPmg - minPmg));
                    return 'background-color: hsl(' + hue + ', 100%, 85%);';
                }

                function updateRowColors(columnIndex) {
                    const table = document.getElementById('questionsTable');
                    const tbody = table.querySelector('tbody');
                    const rows = Array.from(tbody.querySelectorAll('tr'));
                    const numericColorCols = [0, 5, 6, 7];

                    rows.forEach(row => {
                        row.style.backgroundColor = '';
                        row.style.color = '';
                    });

                    if (columnIndex === 8) { // PMG-X
                        const pmgValues = rows.map(row => {
                            const text = row.cells[columnIndex].textContent.trim();
                            if (['NA', 'SA', 'W/H'].includes(text)) return text;
                            return parseFloat(text);
                        });
                        const numericPmgs = pmgValues.filter(v => typeof v === 'number' && v > 1);
                        const minPmg = Math.min(...numericPmgs);
                        const maxPmg = Math.max(...numericPmgs);

                        rows.forEach((row, i) => {
                            const style = getPmgxHighlightColor(pmgValues[i], minPmg, maxPmg);
                            row.setAttribute('style', "cursor: pointer; " + style);
                        });

                    } else if (numericColorCols.includes(columnIndex)) {
                        const values = rows.map(row => parseFloat(row.cells[columnIndex].textContent.trim())).filter(v => !isNaN(v));
                        const min = Math.min(...values);
                        const max = Math.max(...values);

                        rows.forEach(row => {
                            const value = parseFloat(row.cells[columnIndex].textContent.trim());
                            if (isNaN(value)) return;
                            const hue = 120 * (1 - (value - min) / (max - min));
                            row.style.backgroundColor = 'hsl(' + hue + ', 100%, 85%)';
                        });
                    }
                }

                function sortTable(columnIndex) {
                    const table = document.getElementById('questionsTable');
                    const tbody = table.querySelector('tbody');
                    const rows = Array.from(tbody.querySelectorAll('tr'));
                    const headers = table.querySelectorAll('th');

                    const direction = sortDirections[columnIndex] === 'asc' ? 'desc' : 'asc';
                    sortDirections = new Array(headers.length).fill(null);
                    sortDirections[columnIndex] = direction;
                    const directionMultiplier = direction === 'asc' ? 1 : -1;

                    rows.sort((a, b) => {
                        const aText = a.cells[columnIndex].textContent.trim();
                        const bText = b.cells[columnIndex].textContent.trim();

                        const aNum = parseFloat(aText);
                        const bNum = parseFloat(bText);
                        const isNumA = !isNaN(aNum);
                        const isNumB = !isNaN(bNum);

                        // Grouping logic: numbers always come before strings
                        if (isNumA && !isNumB) {
                            return -1;
                        }
                        if (!isNumA && isNumB) {
                            return 1;
                        }

                        // At this point, both are numbers or both are strings.
                        // Sort within the group based on type.
                        if (isNumA) { // Both are numbers
                            return (aNum - bNum) * directionMultiplier;
                        } else { // Both are strings
                            if (columnIndex === 8) { // Special string sort for PMG-X
                                const pmgOrder = { 'W/H': 1, 'SA': 2, 'NA': 3 };
                                const aVal = pmgOrder[aText] || 99;
                                const bVal = pmgOrder[bText] || 99;
                                return (aVal - bVal) * directionMultiplier;
                            }
                            // Standard string sort for other columns
                            return aText.toLowerCase().localeCompare(bText.toLowerCase()) * directionMultiplier;
                        }
                    });

                    headers.forEach(th => th.classList.remove('sort-asc', 'sort-desc'));
                    headers[columnIndex].classList.add(direction === 'asc' ? 'sort-asc' : 'sort-desc');

                    rows.forEach(row => tbody.appendChild(row));
                    updateRowColors(columnIndex);
                }
            </script>
        </body>
        </html>
    `;
}

function getHighlightColor(pmgX: number | string, minPmg: number, maxPmg: number): string {
    if (typeof pmgX === 'string') {
        switch (pmgX) {
            case 'NA':
                return 'background-color: #F0F0F0;'; // light grey for Not Applicable
            case 'SA':
                return 'background-color: #E6E0F8;'; // light purple for Single Attempt
            case 'W/H':
                return 'background-color: #FFDDC1;'; // light orange for With Help
            default:
                return '';
        }
    }

    if (pmgX <= 1) {
        return 'background-color: #006400; color: white;'; // dark green for pmgX <= 1
    }

    // Scale from green (120) to red (0)
    // To make the scale more sensitive to higher values, we can use a non-linear transformation if needed.
    // For now, a linear scale is implemented.
    const hue = 120 * (1 - (pmgX - minPmg) / (maxPmg - minPmg));
    return `background-color: hsl(${hue}, 100%, 85%);`;
}


// =================================================================================================
// FILE: src/db.ts
// =================================================================================================

import * as sqlite3 from "sqlite3";
import * as path from "path";
import {
  CREATE_TABLES_SQL,
  GET_QUESTIONS_SQL,
  UPDATE_QUESTION_SQL,
} from "./db_sql_queries";
import { Question } from "./Question";
import * as vscode from "vscode";
import matter from "gray-matter";

const dbPath = path.resolve(__dirname, "../src/db.db");

export function initializeDatabase() {
  const db = new sqlite3.Database(dbPath, (err) => {
    if (err) {
      console.error(
        `Error opening the SQLite database at ${dbPath}`,
        err.message
      );
    } else {
      console.log(`Connected to the SQLite database at ${dbPath}`);
    }
  });
  db.serialize(() => {
    db.exec(CREATE_TABLES_SQL);
  });
  return db;
}

export async function buildAllQuestions(dbPath: string): Promise<Question[]> {
  return new Promise((resolve, reject) => {
    const db = new sqlite3.Database(dbPath, sqlite3.OPEN_READONLY, (err) => {
      if (err) {
        reject(`Error opening database: ${err.message}`);
      }
    });

    db.all(GET_QUESTIONS_SQL, [], (err, rows: any[]) => {
      if (err) {
        reject(`Error querying database: ${err.message}`);
      } else {
        const questions = rows.map((row) => new Question(row));
        resolve(questions);
      }
      db.close();
    });
  });
}

export async function saveQuestion(document: vscode.TextDocument) {
  const text = document.getText();
  const questionNumberMatch = text.match(/^# Question (\d+)/im);

  if (!questionNumberMatch) {
    vscode.window.showErrorMessage(
      "Could not save: Question number not found in the document."
    );
    return;
  }
  const questionNumber = parseInt(questionNumberMatch[1], 10);

  const parsed = matter(text);
  const content = parsed.content;

  const description = parsed.data.description;

  let proposition = "";
  let stepByStep = "";
  let answer = "";

  const propositionContent = content.split("## Proposition")[1];
  if (propositionContent === undefined) {
    vscode.window.showErrorMessage(
      "Could not save: '## Proposition' section not found."
    );
    return;
  }

  if (propositionContent.includes("## Step-by-step")) {
    const stepByStepSplit = propositionContent.split("## Step-by-step");
    proposition = stepByStepSplit[0].trim();
    const answerSplit = stepByStepSplit[1].split("## Answer");
    if (answerSplit[1] === undefined) {
      vscode.window.showErrorMessage(
        "Could not save: '## Answer' section not found after '## Step-by-step'."
      );
      return;
    }
    stepByStep = answerSplit[0].trim();
    answer = answerSplit[1].trim();
  } else {
    const answerSplit = propositionContent.split("## Answer");
    if (answerSplit[1] === undefined) {
      vscode.window.showErrorMessage(
        "Could not save: '## Answer' section not found."
      );
      return;
    }
    proposition = answerSplit[0].trim();
    answer = answerSplit[1].trim();
  }

  const dbPath = path.join(
    vscode.extensions.getExtension("Nicholas.vscode-cal")!.extensionPath,
    "src",
    "db.db"
  );
  const db = new sqlite3.Database(dbPath);

  db.run(
    UPDATE_QUESTION_SQL,
    [
      parsed.data.discipline,
      parsed.data.source,
      description,
      proposition,
      stepByStep,
      answer,
      parsed.data.tags.join(", "),
      questionNumber,
    ],
    function (err) {
      if (err) {
        vscode.window.showErrorMessage(
          `Error updating question: ${err.message}`
        );
      } else {
        vscode.window.showInformationMessage(
          `Question ${questionNumber} updated successfully.`
        );
      }
    }
  );
  db.close();
}

export async function registerAttempt(questionNumber: number, code: number) {
  const dbPath = path.join(
    vscode.extensions.getExtension("Nicholas.vscode-cal")!.extensionPath,
    "src",
    "db.db"
  );
  const db = new sqlite3.Database(dbPath);

  db.run(
    "INSERT INTO attempts (question_number, code) VALUES (?, ?)",
    [questionNumber, code],
    function (err) {
      if (err) {
        vscode.window.showErrorMessage(
          `Error registering attempt: ${err.message}`
        );
      } else {
        vscode.window.showInformationMessage(
          `Attempt for question ${questionNumber} registered successfully.`
        );
      }
    }
  );
  db.close();
}


// =================================================================================================
// FILE: src/db_sql_queries.ts
// =================================================================================================

export const GET_QUESTIONS_SQL = `
    SELECT
  q.*,
  COALESCE(
    json_group_array(a.code ORDER BY a.attempt_datetime), '[]' ) AS code_vec_json,
  COALESCE(
    json_group_array(a.attempt_datetime ORDER BY a.attempt_datetime), '[]' ) AS date_vec_json
    FROM questions AS q
    LEFT JOIN attempts AS a
    ON a.question_number = q.question_number
    GROUP BY q.question_number
  `;
export const CREATE_QUESTION_SQL = `
    INSERT INTO questions (discipline, source, description, proposition, step_by_step, answer, tags)
    VALUES (?, ?, ?, ?, ?, ?, ?)
`;
export const UPDATE_QUESTION_SQL = `
    UPDATE questions
    SET discipline = ?, source = ?, description = ?, proposition = ?, step_by_step = ?, answer = ?, tags = ?
    WHERE question_number = ?
`;
export const INSERT_ATTEMPT_SQL = `
    INSERT INTO attempts (question_number, code)
    VALUES (?, ?)
`;
export const CREATE_TABLES_SQL = `
    PRAGMA foreign_keys = ON;

    CREATE TABLE IF NOT EXISTS questions (
      question_number INTEGER PRIMARY KEY AUTOINCREMENT,
      discipline      TEXT    NOT NULL,
      source          TEXT    NOT NULL,
      description     TEXT    NOT NULL,
      proposition     TEXT    NOT NULL,
      step_by_step    TEXT,
      answer          TEXT    NOT NULL,
      tags            TEXT    NOT NULL
    );

    CREATE TABLE IF NOT EXISTS attempts (
      id               INTEGER PRIMARY KEY AUTOINCREMENT,
      question_number  INTEGER NOT NULL,
      code             INTEGER NOT NULL,
      attempt_datetime     DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (question_number)
        REFERENCES questions(question_number)
        ON DELETE CASCADE
    );
`;

export const GET_QUESTION_BY_NUMBER_SQL = `
    SELECT
  q.*,
  COALESCE(
    json_group_array(a.code ORDER BY a.attempt_datetime), '[]' ) AS code_vec_json,
  COALESCE(
    json_group_array(a.attempt_datetime ORDER BY a.attempt_datetime), '[]' ) AS date_vec_json
    FROM questions AS q
    LEFT JOIN attempts AS a
    ON a.question_number = q.question_number
    WHERE q.question_number = ?
    GROUP BY q.question_number
`;

export const GET_MAX_QUESTION_NUMBER_SQL = `
    SELECT MAX(question_number) as max_number FROM questions
`;

// =================================================================================================
// FILE: src/diagnostics.ts
// =================================================================================================

import * as vscode from "vscode";
import matter from "gray-matter";

export const diagnosticsCollection =
  vscode.languages.createDiagnosticCollection("question");

export function updateDiagnostics(document: vscode.TextDocument) {
  const diagnostics: vscode.Diagnostic[] = [];
  const text = document.getText();

  const questionNumberMatch = text.match(/^# Question (\d+)/im);

  // If it's not a question file, clear diagnostics and return.
  if (!questionNumberMatch) {
    diagnosticsCollection.set(document.uri, []);
    return;
  }

  const questionNumber = questionNumberMatch[1];

  try {
    const parsed = matter(text);

    // Front matter validation
    if (!parsed.data.discipline) {
      diagnostics.push(
        new vscode.Diagnostic(
          new vscode.Range(0, 0, 0, 1),
          "Front matter is missing the 'discipline' field.",
          vscode.DiagnosticSeverity.Error
        )
      );
    }
    if (!parsed.data.source) {
      diagnostics.push(
        new vscode.Diagnostic(
          new vscode.Range(0, 0, 0, 1),
          "Front matter is missing the 'source' field.",
          vscode.DiagnosticSeverity.Error
        )
      );
    }
    if (!parsed.data.tags || !Array.isArray(parsed.data.tags)) {
      diagnostics.push(
        new vscode.Diagnostic(
          new vscode.Range(0, 0, 0, 1),
          "Front matter must have 'tags' as an array.",
          vscode.DiagnosticSeverity.Error
        )
      );
    }

    // Body validation
    const requiredHeadings = [
      "# Question",
      "## Proposition",
      "## Step-by-step",
      "## Answer",
    ];
    for (const heading of requiredHeadings) {
      if (heading === "# Question") {
        const headingRegex = new RegExp(`^# Question ${questionNumber}`, "im");

        if (!headingRegex.test(text)) {
          diagnostics.push(
            new vscode.Diagnostic(
              new vscode.Range(0, 0, document.lineCount - 1, 1),
              `Markdown body is missing the '# Question ${questionNumber}' heading.`,
              vscode.DiagnosticSeverity.Error
            )
          );
        }
      } else {
        const headingRegex = new RegExp(`^${heading}(\s|$)`, "im");
        if (!headingRegex.test(text)) {
          diagnostics.push(
            new vscode.Diagnostic(
              new vscode.Range(0, 0, document.lineCount - 1, 1),
              `Markdown body is missing the '${heading}' heading.`,
              vscode.DiagnosticSeverity.Error
            )
          );
        }
      }
    }
  } catch (e: any) {
    diagnostics.push(
      new vscode.Diagnostic(
        new vscode.Range(0, 0, 0, 1),
        `Error parsing front matter: ${e.message}`,
        vscode.DiagnosticSeverity.Error
      )
    );
  }

  diagnosticsCollection.set(document.uri, diagnostics);
}


// =================================================================================================
// FILE: src/extension.ts
// =================================================================================================

import * as vscode from "vscode";
import { registerCommands } from "./commands/commandsLoader";
import { updateDiagnostics } from "./diagnostics";
import { SidepanelProvider } from "./sidepanelProvider";

export function activate(context: vscode.ExtensionContext) {
  console.log('Congratulations, your extension "vscode-cal" is now active!');

  registerCommands(context);

  const sidepanelProvider = new SidepanelProvider(context.extensionUri);
  context.subscriptions.push(
    vscode.window.registerWebviewViewProvider(SidepanelProvider.viewType, sidepanelProvider)
  );

  context.subscriptions.push(
    vscode.workspace.onDidOpenTextDocument((doc) => updateDiagnostics(doc))
  );
  context.subscriptions.push(
    vscode.workspace.onDidChangeTextDocument((e) =>
      updateDiagnostics(e.document)
    )
  );
}

export function deactivate() { }


// =================================================================================================
// FILE: src/Question.ts
// =================================================================================================

const MS_PER_DAY = 1000 * 60 * 60 * 24;
const STATUS_NA = "NA";
const STATUS_SA = "SA";
const STATUS_WH = "W/H";

export class Question {
  // From DB
  question_number: number;
  discipline: string;
  source: string;
  description: string;
  proposition: string;
  step_by_step: string | null;
  answer: string;
  tags: string[];
  attempts: { code: number; date: Date }[];

  // Calculated properties
  daysSinceLastAttempt: number | string;
  latestMemoryInterval: number | string;
  potentialMemoryGainMultiplier: number | string;
  potentialMemoryGainInDays: number | string;
  attemptsWithoutHelp: number;
  attemptsWithHelp: number;
  attemptsSummary: string;

  constructor(dbData: any) {
    // Assign data from the database record
    this.question_number = dbData.question_number;
    this.discipline = dbData.discipline;
    this.source = dbData.source;
    this.description = dbData.description;
    this.proposition = dbData.proposition;
    this.step_by_step = dbData.step_by_step;
    this.answer = dbData.answer;
    this.tags = dbData.tags
      ? dbData.tags.split(",").map((tag: string) => tag.trim())
      : [];


    const codeVec: number[] = JSON.parse(dbData.code_vec_json);
    const dateVec: string[] = JSON.parse(dbData.date_vec_json);

    if (codeVec.length === 1 && codeVec[0] === null) {
      this.attempts = [];
    } else {
      this.attempts = codeVec.map((code, index) => ({
        code: code,
        date: new Date(dateVec[index]),
      }));
    }

    this.attemptsWithoutHelp = codeVec.filter((c) => c === 1).length;
    this.attemptsWithHelp = codeVec.filter((c) => c === 0).length;

    if (this.attempts.length === 0) {
      this.daysSinceLastAttempt = STATUS_NA;
      this.latestMemoryInterval = STATUS_NA;
      this.potentialMemoryGainMultiplier = STATUS_NA;
      this.potentialMemoryGainInDays = STATUS_NA;
      this.attemptsSummary = STATUS_NA;
    } else {
      this.daysSinceLastAttempt = this.calculateDaysSinceLastAttempt();
      this.attemptsSummary = this.calculateAttemptsSummary(codeVec);

      const lastCode = codeVec[codeVec.length - 1];
      if (lastCode === 0) {
        this.latestMemoryInterval = STATUS_WH;
        this.potentialMemoryGainMultiplier = STATUS_WH;
        this.potentialMemoryGainInDays = this.daysSinceLastAttempt;
      } else if (lastCode === 1 && codeVec.length === 1) {
        this.latestMemoryInterval = STATUS_SA;
        this.potentialMemoryGainMultiplier = STATUS_SA;
        this.potentialMemoryGainInDays = this.daysSinceLastAttempt;
      } else {
        const memoryIntervals: number[] = [];
        for (let j = 1; j < codeVec.length; j++) {
          if (codeVec[j] === 1) {
            const prev = new Date(dateVec[j - 1]);
            const curr = new Date(dateVec[j]);
            const interval = Math.floor(
              (curr.getTime() - prev.getTime()) / MS_PER_DAY
            );
            memoryIntervals.push(interval);
          }
        }
        const lastInterval = memoryIntervals[memoryIntervals.length - 1];
        const latestInterval = lastInterval === 0 ? 1 : lastInterval;
        this.latestMemoryInterval = latestInterval;
        this.potentialMemoryGainMultiplier = parseFloat(
          ((this.daysSinceLastAttempt as number) / latestInterval).toFixed(2)
        );
        this.potentialMemoryGainInDays = (this.daysSinceLastAttempt as number) - latestInterval;
      }
    }
  }

  private calculateDaysSinceLastAttempt(): number {
    const lastAttemptDate = this.attempts[this.attempts.length - 1].date;
    const today = new Date();
    // Set both dates to midnight to compare just the days
    lastAttemptDate.setHours(0, 0, 0, 0);
    today.setHours(0, 0, 0, 0);
    const diffTime = today.getTime() - lastAttemptDate.getTime();
    return Math.floor(diffTime / MS_PER_DAY);
  }

  private calculateAttemptsSummary(code_vector: number[]) {
    return `${this.attemptsWithoutHelp + this.attemptsWithHelp}; ${this.attemptsWithoutHelp}; ${this.attemptsWithHelp}`;
  }
}


// =================================================================================================
// FILE: src/sidepanelProvider.ts
// =================================================================================================

import * as vscode from "vscode";
import * as fs from "fs";
import * as path from "path";

export class SidepanelProvider implements vscode.WebviewViewProvider {
  public static readonly viewType = "cal-question-view";

  private _view?: vscode.WebviewView;

  constructor(private readonly _extensionUri: vscode.Uri) { }

  public resolveWebviewView(
    webviewView: vscode.WebviewView,
    context: vscode.WebviewViewResolveContext,
    _token: vscode.CancellationToken
  ) {
    this._view = webviewView;

    webviewView.webview.options = {
      // Allow scripts in the webview
      enableScripts: true,

      localResourceRoots: [this._extensionUri],
    };

    webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

    webviewView.webview.onDidReceiveMessage((data) => {
      switch (data.type) {
        case "openQuestion": {
          vscode.commands.executeCommand(
            "vscode-cal.openQuestionByNumber",
            parseInt(data.value)
          );
          break;
        }
        case "previewQuestion": {
          vscode.commands.executeCommand("vscode-cal.previewQuestion");
          break;
        }
        case "saveQuestion": {
          vscode.commands.executeCommand("vscode-cal.saveQuestion");
          break;
        }
        case "recommendQuestion": {
          vscode.commands.executeCommand("vscode-cal.recommendQuestion");
          break;
        }
        case "registerAttempt": {
          vscode.commands.executeCommand(
            "vscode-cal.registerAttempt",
            data.value
          );
          break;
        }
        case "showRankedQuestions": {
          vscode.commands.executeCommand("vscode-cal.showRankedQuestions");
          break;
        }
        case "createQuestion": {
            vscode.commands.executeCommand("vscode-cal.createQuestion");
            break;
        }
      }
    });
  }

  private _getHtmlForWebview(webview: vscode.Webview) {
    const scriptUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, "media", "main.js")
    );

    // Do the same for the stylesheet.
    const styleResetUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, "media", "reset.css")
    );
    const styleVSCodeUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, "media", "vscode.css")
    );
    const styleMainUri = webview.asWebviewUri(
      vscode.Uri.joinPath(this._extensionUri, "media", "main.css")
    );

    const nonce = getNonce();

    const htmlPath = path.join(this._extensionUri.fsPath, 'src', 'sidepanel.html');
    let html = fs.readFileSync(htmlPath, 'utf8');

    html = html.replace(/\${webview.cspSource}/g, webview.cspSource)
      .replace(/\${nonce}/g, nonce)
      .replace(/\${styleResetUri}/g, styleResetUri.toString())
      .replace(/\${styleVSCodeUri}/g, styleVSCodeUri.toString())
      .replace(/\${styleMainUri}/g, styleMainUri.toString());

    return html;
  }
}

function getNonce() {
  let text = "";
  const possible =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (let i = 0; i < 32; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}


// =================================================================================================
// FILE: src/test/extension.test.ts
// =================================================================================================

import * as assert from 'assert';

// You can import and use all API from the 'vscode' module
// as well as import your extension to test it
import * as vscode from 'vscode';
// import * as myExtension from '../../extension';

suite('Extension Test Suite', () => {
	vscode.window.showInformationMessage('Start all tests.');

	test('Sample test', () => {
		assert.strictEqual(-1, [1, 2, 3].indexOf(5));
		assert.strictEqual(-1, [1, 2, 3].indexOf(0));
	});
});


// =================================================================================================
// FILE: src/test/question-management.test.ts
// =================================================================================================

import * as assert from 'assert';
import * as vscode from 'vscode';
import * as sinon from 'sinon';
import * as commands from '../commands/commandsLoader';
import * as db from '../db';
import * as diagnostics from '../diagnostics';
import { Question } from '../Question';

suite('Question Management Commands', () => {
    let showInputBoxStub: sinon.SinonStub;
    let showErrorMessageStub: sinon.SinonStub;
    let buildAllQuestionsStub: sinon.SinonStub;
    let openTextDocumentStub: sinon.SinonStub;
    let showTextDocumentStub: sinon.SinonStub;
    let updateDiagnosticsStub: sinon.SinonStub;

    suiteSetup(() => {
        // Stub vscode functions that are used across tests
        showInputBoxStub = sinon.stub(vscode.window, 'showInputBox');
        showErrorMessageStub = sinon.stub(vscode.window, 'showErrorMessage');
        openTextDocumentStub = sinon.stub(vscode.workspace, 'openTextDocument');
        showTextDocumentStub = sinon.stub(vscode.window, 'showTextDocument');
        buildAllQuestionsStub = sinon.stub(db, 'buildAllQuestions');
        updateDiagnosticsStub = sinon.stub(diagnostics, 'updateDiagnostics');

        // Register commands once
        const tempContext = { subscriptions: [], extensionPath: '/mock/path' } as any;
        commands.registerCommands(tempContext);
    });

    suiteTeardown(() => {
        sinon.restore();
    });

    teardown(() => {
        // Reset the state of the stubs
        showInputBoxStub.reset();
        showErrorMessageStub.reset();
        buildAllQuestionsStub.reset();
        openTextDocumentStub.reset();
        showTextDocumentStub.reset();
        updateDiagnosticsStub.reset();
    });

    suite('openQuestionByNumber', () => {
        test('should not show an error when input is cancelled', async () => {
            showInputBoxStub.resolves(undefined);

            await vscode.commands.executeCommand('vscode-cal.openQuestionByNumber');

            assert.strictEqual(showErrorMessageStub.called, false, 'showErrorMessage was called unexpectedly');
        });

        test('should show an error if the question number does not exist', async () => {
            const nonExistentQuestionNumber = '9999';
            showInputBoxStub.resolves(nonExistentQuestionNumber);
            buildAllQuestionsStub.resolves([]); // No questions found

            await vscode.commands.executeCommand('vscode-cal.openQuestionByNumber');

            assert.ok(
                showErrorMessageStub.calledWith(`Question number ${nonExistentQuestionNumber} not found.`),
                'Error message for non-existent question was not shown'
            );
        });

        test('should open a new markdown editor with the question content on success', async () => {
            const questionNumber = '1';
            const mockQuestionData = {
                question_number: 1,
                discipline: 'Math',
                source: 'Test Book',
                description: 'A test question',
                proposition: 'What is 2+2?',
                step_by_step: 'First, take 2. Then, add 2.',
                answer: '4',
                tags: 'calculus, easy',
                code_vec_json: '[1]',
                date_vec_json: '["2025-07-20T12:00:00.000Z"]'
            };
            const mockQuestion = new Question(mockQuestionData);

            showInputBoxStub.resolves(questionNumber);
            buildAllQuestionsStub.resolves([mockQuestion]);
            openTextDocumentStub.resolves({} as vscode.TextDocument);
            showTextDocumentStub.resolves({} as vscode.TextEditor);

            await vscode.commands.executeCommand('vscode-cal.openQuestionByNumber');

            assert.ok(openTextDocumentStub.calledOnce, 'openTextDocument was not called');
            assert.ok(showTextDocumentStub.calledOnce, 'showTextDocument was not called');
            assert.strictEqual(showErrorMessageStub.called, false, 'showErrorMessage was called unexpectedly on success');

            const contentArg = openTextDocumentStub.firstCall.args[0].content;
            assert.ok(contentArg.includes(`# Question ${mockQuestion.question_number}`), 'Content does not contain question number');
            assert.ok(contentArg.includes(`discipline: ${JSON.stringify(mockQuestion.discipline)}`), 'Content does not contain discipline');
            assert.ok(contentArg.includes(`## Proposition\n${mockQuestion.proposition}`), 'Content does not contain proposition');
        });
    });
});


// =================================================================================================
// FILE: src/webview.ts
// =================================================================================================

import * as vscode from "vscode";
import matter from "gray-matter";
import markdownit from "markdown-it";
import katex from "@vscode/markdown-it-katex";

function getNonce() {
  let text = "";
  const possible =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (let i = 0; i < 32; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}

export function getWebviewContent(
  text: string,
  panel: vscode.WebviewPanel,
  context: vscode.ExtensionContext
) {
  const editor = vscode.window.activeTextEditor;
  const docUri = editor ? editor.document.uri : undefined;

  const md = new markdownit({
    html: true,
    linkify: true,
    breaks: true,
  }).use(katex);

  const { content } = matter(text);

  const defaultImageRenderer = md.renderer.rules.image!;

  md.renderer.rules.image = (tokens, idx, options, env, self) => {
    const token = tokens[idx];
    const src = token.attrGet("src");

    if (src && !src.startsWith("http") && docUri) {
      const workspaceFolders = vscode.workspace.workspaceFolders;

      let mainFolder;
      let folderPath;
      if (workspaceFolders && workspaceFolders.length > 0) {
        mainFolder = workspaceFolders[0];
        folderPath = mainFolder.uri.fsPath;
        console.log(`The user is in the workspace: ${folderPath}`);
      } else {
        vscode.window.showInformationMessage(
          "No folder is currently open in the workspace."
        );
      }

      if (mainFolder) {
        const onDiskUri = vscode.Uri.joinPath(mainFolder.uri, src);
        const webviewUri = panel.webview.asWebviewUri(onDiskUri);
        token.attrSet("src", webviewUri.toString());
      }
    }
    return defaultImageRenderer(tokens, idx, options, env, self);
  };

  const html = md.render(content);

  const katexCss = vscode.Uri.joinPath(
    context.extensionUri,
    "node_modules",
    "katex",
    "dist",
    "katex.min.css"
  );
  const katexJs = vscode.Uri.joinPath(
    context.extensionUri,
    "node_modules",
    "katex",
    "dist",
    "katex.min.js"
  );
  const autoRenderJs = vscode.Uri.joinPath(
    context.extensionUri,
    "node_modules",
    "katex",
    "dist",
    "contrib",
    "auto-render.min.js"
  );

  const katexCssUri = panel.webview.asWebviewUri(katexCss);
  const katexJsUri = panel.webview.asWebviewUri(katexJs);
  const autoRenderJsUri = panel.webview.asWebviewUri(autoRenderJs);
  const nonce = getNonce();

  return /*html*/ `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta
          http-equiv="Content-Security-Policy"
          content="default-src 'none'; style-src ${panel.webview.cspSource} 'unsafe-inline'; font-src ${panel.webview.cspSource}; script-src 'nonce-${nonce}'; img-src ${panel.webview.cspSource} https: data:;"
        />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Question Preview</title>
        <link rel="stylesheet" href="${katexCssUri}">
        <script defer src="${katexJsUri}" nonce="${nonce}"></script>
        <script defer src="${autoRenderJsUri}" nonce="${nonce}"></script>
        <script nonce="${nonce}">
          document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
              delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
              ]
            });
          });
        </script>
    </head>
    <body>
        ${html}
    </body>
    </html>
  `;
}

